# R√®gles de d√©veloppement - POS Restaurant Les Emirs

## üéØ Contexte du projet
Ce projet est un **syst√®me POS (Point of Sale) pour restaurant** fonctionnant sur **PC Windows tactile**. 
L'application Flutter g√®re les commandes, paiements, et rapports financiers en temps r√©el.

## ‚ö†Ô∏è R√àGLES CRITIQUES - √Ä RESPECTER ABSOLUMENT

### 1. Calculs financiers et paiements
**NE JAMAIS modifier les calculs de paiement, pourboires, remises, ou totaux sans :**
- Analyser l'impact sur les rapports X, KPI, et historique
- Comprendre la diff√©rence entre `enteredAmount`, `allocatedAmount`, et `excessAmount`
- V√©rifier les cons√©quences sur `totalRecette`, `chiffreAffaire`, et les pourboires par serveur
- **Demander une autorisation explicite** avant toute modification

**Fichiers critiques √† manipuler avec pr√©caution :**
- `server/controllers/pos-payment.js` - Logique de paiement et calcul des pourboires
- `server/controllers/pos-report-x.js` - G√©n√©ration des rapports financiers
- `server/utils/history-processor.js` - Traitement de l'historique des paiements
- `server/utils/payment-processor.js` - **SOURCE DE V√âRIT√â UNIQUE** pour la d√©duplication des paiements
- `flutter_les_emirs/lib/features/pos/pages/payment/services/payment_validation_service.dart` - Validation des paiements

### 2. Source de v√©rit√© unique
**TOUJOURS utiliser `_currentAllOrders` (backend) via `getAllItemsOrganized()`** pour les quantit√©s non pay√©es.
- ‚ùå Ne jamais utiliser `mainNote.items` ou `subNotes` directement pour les calculs
- ‚úÖ Toujours passer par `PaymentValidationService.getItemsToPay()` pour obtenir les articles √† payer
- Les quantit√©s pay√©es (`paidQuantity`) sont la source de v√©rit√© pour le suivi des paiements partiels

### 2.1. ‚ö†Ô∏è MULTIPLES COMMANDES PAR TABLE (CRITIQUE)
**UNE TABLE PEUT AVOIR PLUSIEURS COMMANDES (orders) DISTINCTES** :
- Une table peut avoir : Commande #1 (orderId: 1), Commande #2 (orderId: 2), Commande #3 (orderId: 3), etc.
- Chaque commande a son propre `orderId`, `mainNote`, `subNotes`, et `paymentHistory`
- **TOUJOURS consid√©rer cette multiplicit√© lors des modifications** :
  - ‚úÖ Les calculs de totaux doivent agr√©ger TOUTES les commandes de la table
  - ‚úÖ La r√©partition des montants/pourboires doit √™tre **proportionnelle par commande** (voir `payMultiOrders`)
  - ‚úÖ `processItemAcrossTable` cherche dans TOUTES les commandes de la table (FIFO)
  - ‚úÖ Les paiements peuvent concerner plusieurs commandes en une seule transaction (`splitPaymentId` regroupe tout)
  - ‚ùå Ne jamais supposer qu'une table = une seule commande
  - ‚ùå Ne jamais calculer un total sans v√©rifier toutes les commandes de la table

### 3. Paiements divis√©s (Split Payments)
- Les paiements divis√©s utilisent `splitPaymentId` (format: `split_TIMESTAMP`) pour regrouper tous les modes
- Le flag `hasCashInPayment` d√©termine si le pourboire scriptural doit √™tre comptabilis√© ou non
- Quand `hasCashInPayment === true`, le pourboire est purement indicatif et ne doit PAS √™tre inclus dans `totalRecette`
- Regrouper les paiements par `splitPaymentId` dans les rapports (pas par mode individuel)
- **‚ö†Ô∏è Paiement multi-commandes** : Un paiement peut concerner plusieurs commandes (plusieurs `orderId`) en une seule transaction
  - La r√©partition proportionnelle se fait via `proportion = orderSubtotal / totalSubtotal` dans `payMultiOrders`
  - Chaque commande enregistre son propre `paymentRecord` dans son `paymentHistory` avec le m√™me `splitPaymentId`

### 3.1. ‚ö†Ô∏è SOURCE DE V√âRIT√â UNIQUE POUR LA D√âDUPLICATION
**Le module `server/utils/payment-processor.js` est la source de v√©rit√© pour la d√©duplication des paiements.**
- ‚úÖ `pos-report-x.js` (X Report, KPI) utilise `paymentProcessor.calculatePaymentsByMode()` et `paymentProcessor.deduplicateAndCalculate()`
- ‚úÖ `history-processor.js` (Historique) utilise les m√™mes principes de d√©duplication
- ‚úÖ Cela garantit que **History = KPI = X Report** (coh√©rence des donn√©es)
- **Cl√© de d√©duplication** : `splitPaymentId + mode + enteredAmount` pour identifier les transactions uniques
- **Probl√®me r√©solu** : Pour N commandes, chaque transaction appara√Æt N fois dans `paymentHistory`. Le module commun d√©duplique correctement.

### 3.2. ‚ö†Ô∏è INTERDICTION D'UTILISER TIMESTAMP POUR LA D√âDUPLICATION OU REGROUPEMENT
**‚ùå NE JAMAIS utiliser le timestamp pour d√©dupliquer, regrouper ou identifier des transactions/entit√©s.**
- ‚ùå Le timestamp n'est **PAS fiable** pour la d√©duplication (plusieurs entit√©s peuvent avoir le m√™me timestamp)
- ‚ùå Le timestamp n'est **PAS fiable** pour le regroupement (probl√®mes de pr√©cision, arrondis, collisions)
- ‚úÖ **TOUJOURS utiliser des identifiants d√©di√©s** (`splitPaymentId`, `orderId`, `paymentId`, etc.) quand ils existent
- ‚úÖ **Cl√© de d√©duplication** : Utiliser des combinaisons d'identifiants (`splitPaymentId + mode + enteredAmount`, etc.)
- **R√®gle absolue** : Si un identifiant d√©di√© existe, l'utiliser. Ne jamais utiliser le timestamp comme alternative.
- **Exception** : Le timestamp peut √™tre utilis√© uniquement comme fallback pour les anciennes donn√©es sans identifiant (r√©trocompatibilit√© uniquement)
- **Exemples de bonnes pratiques** :
  - ‚úÖ Paiements divis√©s : `splitPaymentId` pour regrouper
  - ‚úÖ Commandes : `orderId` pour identifier
  - ‚úÖ Transactions : `paymentId` ou `splitPaymentId + mode + enteredAmount` pour d√©dupliquer
  - ‚ùå Ne jamais : `timestamp` pour regrouper des paiements divis√©s
  - ‚ùå Ne jamais : `timestamp` pour d√©dupliquer des transactions

### 4. Interface tactile Windows
- **Optimiser pour l'interaction tactile** : boutons suffisamment grands, espacement appropri√©
- **Dialogs positionn√©s correctement** : utiliser `showGeneralDialog` avec `Align(topCenter)` pour √©viter les conflits avec le clavier virtuel
- **Clavier virtuel** : pr√©voir `selectAllOnFocus: true` pour les champs de montant (gain de temps)
- **Scroll fluide** : utiliser `SingleChildScrollView` avec `BouncingScrollPhysics` dans les dialogs

### 5. Synchronisation temps r√©el
- Les donn√©es viennent du backend via **Socket.IO** (`HomeSocketService`, `OrderSocketService`)
- **Ne jamais modifier directement** les donn√©es locales sans synchronisation backend
- Toujours utiliser les services d√©di√©s (`OrdersSyncService`, `PaymentService`) pour les op√©rations

### 5.1. ‚ö†Ô∏è APPLICATIONS FLUTTER MULTIPLES - DASHBOARD ADMIN (CRITIQUE - PRIORIT√â ABSOLUE)
**Il existe DEUX applications Flutter distinctes qui partagent le m√™me code admin :**
- **`flutter_les_emirs/`** : Application POS principale (Windows tactile) avec dashboard admin int√©gr√©
- **`flutter_admin_app/`** : Application Admin Android ind√©pendante avec son propre dashboard

**‚ö†Ô∏è R√àGLE ABSOLUE - √Ä RESPECTER EN PREMIER : Lors de toute modification du code admin (dashboard, historique, KPI, tickets, rapports), TOUJOURS modifier les DEUX applications :**
- ‚úÖ `flutter_les_emirs/lib/features/admin/` 
- ‚úÖ `flutter_admin_app/lib/features/admin/`

**‚ö†Ô∏è NE JAMAIS modifier une seule application sans modifier l'autre !**

**Fichiers √† modifier en double (liste non exhaustive) :**
- `pages/paid_history_page.dart` - Historique des encaissements
- `widgets/paid_ticket_dialog.dart` - Dialog des tickets
- `widgets/paid_history_dialog.dart` - Dialog de l'historique
- `pages/admin_dashboard_page.dart` - Dashboard principal
- `widgets/admin_dashboard_kpi_section.dart` - Section KPI
- `widgets/enriched_history_section.dart` - Section historique
- `pages/report_x_page.dart` - Page Rapport X
- **Tous les autres fichiers dans `features/admin/`**

**Workflow obligatoire :**
1. ‚úÖ Identifier le fichier √† modifier dans `flutter_les_emirs/lib/features/admin/`
2. ‚úÖ Appliquer la modification dans `flutter_les_emirs/`
3. ‚úÖ **IMM√âDIATEMENT** appliquer la m√™me modification dans `flutter_admin_app/lib/features/admin/`
4. ‚úÖ V√©rifier que les modifications sont identiques dans les deux apps
5. ‚úÖ Tester les deux apps si possible
6. ‚úÖ Documenter si une diff√©rence est intentionnelle

**‚ö†Ô∏è Cette r√®gle doit √™tre v√©rifi√©e AVANT chaque commit et AVANT chaque r√©ponse √† l'utilisateur.**

## üìã Bonnes pratiques g√©n√©rales

### Architecture
- **Flutter frontend POS** : `lib/features/pos/pages/` (home, order, payment)
- **Flutter frontend Admin** : `lib/features/admin/` (dashboard, rapport X, cr√©dit, serveurs)
  - `admin_dashboard_page.dart` - Dashboard principal avec KPI et historique
  - `widgets/admin_dashboard_kpi_section.dart` - Section KPI (utilise les m√™mes donn√©es que X Report)
  - `widgets/enriched_history_section.dart` - Section historique (utilise history-processor.js)
  - `report_x_page.dart` - Page Rapport X
- **Node.js backend** : `server/controllers/` (pos-payment.js, pos-report-x.js, credit.js)
- **Utilitaires backend** : `server/utils/` (payment-processor.js, history-processor.js)
- **Documentation** : Consulter `STRUCTURE_POS.md` (vue d'ensemble) et les fichiers d√©di√©s :
  - `STRUCTURE_POS_HOME.md` - Module Home
  - `STRUCTURE_POS_ORDER.md` - Module Order
  - `STRUCTURE_POS_PAYMENT.md` - Module Payment
  - `STRUCTURE_POS_ADMIN.md` - Module Admin Dashboard
  - `STRUCTURE_SERVEUR.md` - Backend

### Paiements
- Distinguer **paiement simple** vs **paiement divis√©** (split)
- G√©rer les **paiements partiels** via `paidQuantity` sur les articles
- Les **remises** doivent √™tre justifi√©es avec un nom de client (`discountClientName`)
- Les **cr√©dits clients** n√©cessitent nom + t√©l√©phone obligatoires

### Rapports et historique
- Les montants dans l'historique doivent utiliser `enteredAmount` (montant r√©ellement encaiss√©)
- Les pourboires sont affich√©s s√©par√©ment en bas du r√©capitulatif X Report
- La recette encaiss√©e du jour = recette op√©rationnelle (sans pourboire) + pourboires

### Commandes client (Architecture "Bo√Æte aux Lettres")
- Les commandes client arrivent via MongoDB avec `waitingForPos: true`
- Polling automatique toutes les 5 secondes via `pullFromMailbox()`
- Une fois confirm√©es, elles sont g√©r√©es comme les commandes POS normales

### Documentation (Mise √† jour automatique)
**‚ö†Ô∏è OBLIGATOIRE : Mettre √† jour la documentation apr√®s chaque modification de fonctionnalit√©**

La documentation est organis√©e de mani√®re modulaire pour √©viter que `STRUCTURE_POS.md` devienne trop volumineux :

- **`STRUCTURE_POS.md`** : Vue d'ensemble et index (carte de navigation)
- **`STRUCTURE_POS_HOME.md`** : Module Home (plan de table, historique, synchronisation)
- **`STRUCTURE_POS_ORDER.md`** : Module Order (commandes, notes, transferts, annulations)
- **`STRUCTURE_POS_PAYMENT.md`** : Module Payment (paiements, remises, cr√©dits, pourboires)
- **`STRUCTURE_POS_ADMIN.md`** : Module Admin Dashboard (KPI, historique enrichi, rapport X)
- **`STRUCTURE_SERVEUR.md`** : Backend (API, endpoints, serveurs)

**R√®gles de mise √† jour** :
1. **Apr√®s chaque ajout/modification de fonctionnalit√©**, mettre √† jour :
   - Le fichier MD d√©di√© correspondant (HOME/ORDER/PAYMENT/ADMIN/SERVEUR) avec les d√©tails
   - `STRUCTURE_POS.md` si l'architecture globale change (nouveau module, changement de structure)
2. **Pour les changements critiques** (calculs financiers, architecture) :
   - Documenter dans le fichier MD d√©di√©
   - Ajouter une entr√©e dans "Changements r√©cents" de `STRUCTURE_POS.md`
   - Mettre √† jour la date de derni√®re mise √† jour
3. **Pour les nouveaux modules** :
   - Cr√©er un nouveau fichier `STRUCTURE_POS_[MODULE].md` si n√©cessaire
   - Ajouter la r√©f√©rence dans `STRUCTURE_POS.md` (section R√©f√©rences)
   - Mettre √† jour l'index rapide et la table "O√π trouver..."

## üîç Avant de modifier du code

**‚ö†Ô∏è √âTAPE 0 - PRIORIT√â ABSOLUE : V√©rifier si la modification concerne le code admin**
- Si OUI ‚Üí **IMM√âDIATEMENT** v√©rifier la section 5.1 et modifier les DEUX applications
- Ne jamais modifier une seule application admin sans modifier l'autre

1. **Identifier le module concern√©** : Home, Order, Payment, ou Admin (voir `STRUCTURE_POS.md`)
2. **‚ö†Ô∏è Si Admin : V√©rifier les deux applications** (voir section 5.1)
3. **V√©rifier les d√©pendances** : Quels services/utilisateurs sont impact√©s ?
4. **‚ö†Ô∏è V√©rifier la multiplicit√© des commandes** : Est-ce que le code g√®re correctement plusieurs commandes par table ?
   - Les calculs agr√®gent-ils toutes les commandes de la table ?
   - La r√©partition proportionnelle est-elle correcte pour chaque commande ?
   - Les paiements multi-commandes sont-ils bien g√©r√©s ?
5. **Tester les calculs** : V√©rifier les totaux, pourboires, remises dans le X Report
6. **Valider l'UI tactile** : S'assurer que les interactions sont fluides sur √©cran tactile
7. **Documenter** : Mettre √† jour la documentation si l'architecture change (voir section Documentation ci-dessous)

## üö´ √Ä √©viter

- Modifier les calculs financiers sans comprendre `enteredAmount` vs `allocatedAmount`
- Utiliser `mainNote.items` directement au lieu de `getAllItemsOrganized()`
- **Supposer qu'une table = une seule commande** (une table peut avoir plusieurs orders)
- **Oublier la r√©partition proportionnelle** lors des paiements multi-commandes
- Oublier de g√©rer `hasCashInPayment` pour les paiements divis√©s avec liquide
- Cr√©er des dialogs sans gestion du clavier virtuel
- Modifier les donn√©es sans passer par les services de synchronisation
- Calculer des totaux sans v√©rifier toutes les commandes de la table

## üì¶ Gestion GitHub

**‚ö†Ô∏è IMPORTANT : GitHub contient uniquement le code serveur (dossier `server/`).**

- **Ne faire des commits/push GitHub QUE pour les modifications concernant le serveur** (backend Node.js)
- Les modifications Flutter (frontend POS, admin, client, cuisine) ne doivent PAS √™tre commit√©es sur GitHub
- Avant de faire un commit, v√©rifier que seules les modifications dans `server/` sont incluses
- Si des modifications Flutter sont accidentellement incluses, les retirer du commit avant de push

