# R√®gles de d√©veloppement - POS Restaurant Les Emirs

## üéØ Contexte du projet
Ce projet est un **syst√®me POS (Point of Sale) pour restaurant** fonctionnant sur **PC Windows tactile**. 
L'application Flutter g√®re les commandes, paiements, et rapports financiers en temps r√©el.

## ‚ö†Ô∏è R√àGLES CRITIQUES - √Ä RESPECTER ABSOLUMENT

### 1. Calculs financiers et paiements
**NE JAMAIS modifier les calculs de paiement, pourboires, remises, ou totaux sans :**
- Analyser l'impact sur les rapports X, KPI, et historique
- Comprendre la diff√©rence entre `enteredAmount`, `allocatedAmount`, et `excessAmount`
- V√©rifier les cons√©quences sur `totalRecette`, `chiffreAffaire`, et les pourboires par serveur
- **Demander une autorisation explicite** avant toute modification

**Fichiers critiques √† manipuler avec pr√©caution :**
- `server/controllers/pos-payment.js` - Logique de paiement et calcul des pourboires
- `server/controllers/pos-report-x.js` - G√©n√©ration des rapports financiers
- `server/utils/history-processor.js` - Traitement de l'historique des paiements
- `server/utils/payment-processor.js` - **SOURCE DE V√âRIT√â UNIQUE** pour la d√©duplication des paiements
- `flutter_les_emirs/lib/features/pos/pages/payment/services/payment_validation_service.dart` - Validation des paiements

### 2. Source de v√©rit√© unique
**TOUJOURS utiliser `_currentAllOrders` (backend) via `getAllItemsOrganized()`** pour les quantit√©s non pay√©es.
- ‚ùå Ne jamais utiliser `mainNote.items` ou `subNotes` directement pour les calculs
- ‚úÖ Toujours passer par `PaymentValidationService.getItemsToPay()` pour obtenir les articles √† payer
- Les quantit√©s pay√©es (`paidQuantity`) sont la source de v√©rit√© pour le suivi des paiements partiels

### 2.1. ‚ö†Ô∏è MULTIPLES COMMANDES PAR TABLE (CRITIQUE)
**UNE TABLE PEUT AVOIR PLUSIEURS COMMANDES (orders) DISTINCTES** :
- Une table peut avoir : Commande #1 (orderId: 1), Commande #2 (orderId: 2), Commande #3 (orderId: 3), etc.
- Chaque commande a son propre `orderId`, `mainNote`, `subNotes`, et `paymentHistory`
- **TOUJOURS consid√©rer cette multiplicit√© lors des modifications** :
  - ‚úÖ Les calculs de totaux doivent agr√©ger TOUTES les commandes de la table
  - ‚úÖ La r√©partition des montants/pourboires doit √™tre **proportionnelle par commande** (voir `payMultiOrders`)
  - ‚úÖ `processItemAcrossTable` cherche dans TOUTES les commandes de la table (FIFO)
  - ‚úÖ Les paiements peuvent concerner plusieurs commandes en une seule transaction (`splitPaymentId` regroupe tout)
  - ‚ùå Ne jamais supposer qu'une table = une seule commande
  - ‚ùå Ne jamais calculer un total sans v√©rifier toutes les commandes de la table

### 3. Paiements divis√©s (Split Payments)
- Les paiements divis√©s utilisent `splitPaymentId` (format: `split_TIMESTAMP`) pour regrouper tous les modes
- Le flag `hasCashInPayment` d√©termine si le pourboire scriptural doit √™tre comptabilis√© ou non
- Quand `hasCashInPayment === true`, le pourboire est purement indicatif et ne doit PAS √™tre inclus dans `totalRecette`
- Regrouper les paiements par `splitPaymentId` dans les rapports (pas par mode individuel)
- **‚ö†Ô∏è Paiement multi-commandes** : Un paiement peut concerner plusieurs commandes (plusieurs `orderId`) en une seule transaction
  - La r√©partition proportionnelle se fait via `proportion = orderSubtotal / totalSubtotal` dans `payMultiOrders`
  - Chaque commande enregistre son propre `paymentRecord` dans son `paymentHistory` avec le m√™me `splitPaymentId`

### 3.1. ‚ö†Ô∏è SOURCE DE V√âRIT√â UNIQUE POUR LA D√âDUPLICATION
**Le module `server/utils/payment-processor.js` est la source de v√©rit√© pour la d√©duplication des paiements.**
- ‚úÖ `pos-report-x.js` (X Report, KPI) utilise `paymentProcessor.calculatePaymentsByMode()` et `paymentProcessor.deduplicateAndCalculate()`
- ‚úÖ `history-processor.js` (Historique) utilise les m√™mes principes de d√©duplication
- ‚úÖ Cela garantit que **History = KPI = X Report** (coh√©rence des donn√©es)
- **Cl√© de d√©duplication** : `splitPaymentId + mode + enteredAmount` pour identifier les transactions uniques
- **Probl√®me r√©solu** : Pour N commandes, chaque transaction appara√Æt N fois dans `paymentHistory`. Le module commun d√©duplique correctement.

### 4. Interface tactile Windows
- **Optimiser pour l'interaction tactile** : boutons suffisamment grands, espacement appropri√©
- **Dialogs positionn√©s correctement** : utiliser `showGeneralDialog` avec `Align(topCenter)` pour √©viter les conflits avec le clavier virtuel
- **Clavier virtuel** : pr√©voir `selectAllOnFocus: true` pour les champs de montant (gain de temps)
- **Scroll fluide** : utiliser `SingleChildScrollView` avec `BouncingScrollPhysics` dans les dialogs

### 5. Synchronisation temps r√©el
- Les donn√©es viennent du backend via **Socket.IO** (`HomeSocketService`, `OrderSocketService`)
- **Ne jamais modifier directement** les donn√©es locales sans synchronisation backend
- Toujours utiliser les services d√©di√©s (`OrdersSyncService`, `PaymentService`) pour les op√©rations

## üìã Bonnes pratiques g√©n√©rales

### Architecture
- **Flutter frontend POS** : `lib/features/pos/pages/` (home, order, payment)
- **Flutter frontend Admin** : `lib/features/admin/` (dashboard, rapport X, cr√©dit, serveurs)
  - `admin_dashboard_page.dart` - Dashboard principal avec KPI et historique
  - `widgets/admin_dashboard_kpi_section.dart` - Section KPI (utilise les m√™mes donn√©es que X Report)
  - `widgets/enriched_history_section.dart` - Section historique (utilise history-processor.js)
  - `report_x_page.dart` - Page Rapport X
- **Node.js backend** : `server/controllers/` (pos-payment.js, pos-report-x.js, credit.js)
- **Utilitaires backend** : `server/utils/` (payment-processor.js, history-processor.js)
- **Documentation** : Consulter `STRUCTURE_POS.md` (vue d'ensemble) et les fichiers d√©di√©s :
  - `STRUCTURE_POS_HOME.md` - Module Home
  - `STRUCTURE_POS_ORDER.md` - Module Order
  - `STRUCTURE_POS_PAYMENT.md` - Module Payment
  - `STRUCTURE_POS_ADMIN.md` - Module Admin Dashboard
  - `STRUCTURE_SERVEUR.md` - Backend

### Paiements
- Distinguer **paiement simple** vs **paiement divis√©** (split)
- G√©rer les **paiements partiels** via `paidQuantity` sur les articles
- Les **remises** doivent √™tre justifi√©es avec un nom de client (`discountClientName`)
- Les **cr√©dits clients** n√©cessitent nom + t√©l√©phone obligatoires

### Rapports et historique
- Les montants dans l'historique doivent utiliser `enteredAmount` (montant r√©ellement encaiss√©)
- Les pourboires sont affich√©s s√©par√©ment en bas du r√©capitulatif X Report
- La recette encaiss√©e du jour = recette op√©rationnelle (sans pourboire) + pourboires

### Commandes client (Architecture "Bo√Æte aux Lettres")
- Les commandes client arrivent via MongoDB avec `waitingForPos: true`
- Polling automatique toutes les 5 secondes via `pullFromMailbox()`
- Une fois confirm√©es, elles sont g√©r√©es comme les commandes POS normales

### Documentation (Mise √† jour automatique)
**‚ö†Ô∏è OBLIGATOIRE : Mettre √† jour la documentation apr√®s chaque modification de fonctionnalit√©**

La documentation est organis√©e de mani√®re modulaire pour √©viter que `STRUCTURE_POS.md` devienne trop volumineux :

- **`STRUCTURE_POS.md`** : Vue d'ensemble et index (carte de navigation)
- **`STRUCTURE_POS_HOME.md`** : Module Home (plan de table, historique, synchronisation)
- **`STRUCTURE_POS_ORDER.md`** : Module Order (commandes, notes, transferts, annulations)
- **`STRUCTURE_POS_PAYMENT.md`** : Module Payment (paiements, remises, cr√©dits, pourboires)
- **`STRUCTURE_POS_ADMIN.md`** : Module Admin Dashboard (KPI, historique enrichi, rapport X)
- **`STRUCTURE_SERVEUR.md`** : Backend (API, endpoints, serveurs)

**R√®gles de mise √† jour** :
1. **Apr√®s chaque ajout/modification de fonctionnalit√©**, mettre √† jour :
   - Le fichier MD d√©di√© correspondant (HOME/ORDER/PAYMENT/ADMIN/SERVEUR) avec les d√©tails
   - `STRUCTURE_POS.md` si l'architecture globale change (nouveau module, changement de structure)
2. **Pour les changements critiques** (calculs financiers, architecture) :
   - Documenter dans le fichier MD d√©di√©
   - Ajouter une entr√©e dans "Changements r√©cents" de `STRUCTURE_POS.md`
   - Mettre √† jour la date de derni√®re mise √† jour
3. **Pour les nouveaux modules** :
   - Cr√©er un nouveau fichier `STRUCTURE_POS_[MODULE].md` si n√©cessaire
   - Ajouter la r√©f√©rence dans `STRUCTURE_POS.md` (section R√©f√©rences)
   - Mettre √† jour l'index rapide et la table "O√π trouver..."

## üîç Avant de modifier du code

1. **Identifier le module concern√©** : Home, Order, Payment, ou Admin (voir `STRUCTURE_POS.md`)
2. **V√©rifier les d√©pendances** : Quels services/utilisateurs sont impact√©s ?
3. **‚ö†Ô∏è V√©rifier la multiplicit√© des commandes** : Est-ce que le code g√®re correctement plusieurs commandes par table ?
   - Les calculs agr√®gent-ils toutes les commandes de la table ?
   - La r√©partition proportionnelle est-elle correcte pour chaque commande ?
   - Les paiements multi-commandes sont-ils bien g√©r√©s ?
4. **Tester les calculs** : V√©rifier les totaux, pourboires, remises dans le X Report
5. **Valider l'UI tactile** : S'assurer que les interactions sont fluides sur √©cran tactile
6. **Documenter** : Mettre √† jour la documentation si l'architecture change (voir section Documentation ci-dessous)

## üö´ √Ä √©viter

- Modifier les calculs financiers sans comprendre `enteredAmount` vs `allocatedAmount`
- Utiliser `mainNote.items` directement au lieu de `getAllItemsOrganized()`
- **Supposer qu'une table = une seule commande** (une table peut avoir plusieurs orders)
- **Oublier la r√©partition proportionnelle** lors des paiements multi-commandes
- Oublier de g√©rer `hasCashInPayment` pour les paiements divis√©s avec liquide
- Cr√©er des dialogs sans gestion du clavier virtuel
- Modifier les donn√©es sans passer par les services de synchronisation
- Calculer des totaux sans v√©rifier toutes les commandes de la table

